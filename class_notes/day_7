The Truth Terms
In Python we have the following terms (characters and phrases) for determining if something is ”True” or ”False.” 
Logic on a computer is all about seeing if some combination of these characters and some variables is True at that point in the program.

* and 
• or
• not
• != (not equal)
• == (equal)
• >= (greater-than-equal) • <= (less-than-equal)
• True
• False
You actually have run into these characters before but maybe not the terms. The terms (and, or, not) actually work the way you expect them to, just like in English.

The Truth Tables
We will now use these characters to make the truth tables you need to memorize.
REFER LPTHW


Boolean Practice


Terminal EX:

1. True and True
2. False and True
3. 1==1and2==1 4. "test" == "test"
5. 1==1or2!=1
6. Trueand1==1
7. False and 0 != 0
8. Trueor1==1
9. "test" == "testing"
10. 1!=0and2==1
11. "test" != "testing"
12. "test" == 1
13. not (True and False)
14. not(1==1and0!=1)
15. not (10 == 1 or 1000 == 1000)
16. not(1!=10or3==4)
17. not ("testing" == "testing" and "Zed" == "Cool Guy") 18. 1==1and(not("testing"==1or1==0))
19. "chunky" == "bacon" and (not (3 == 4 or 3 == 3))
20. 3 == 3 and (not ("testing" == "testing" or "Python" == "Fun"))

Whenever you see these Boolean logic statements, 
you can solve them easily by this simple process:
1. Find an equality test (== or !=) and replace it with its truth. 
2. Findeachand/orinsideparenthesesandsolvethosefirst. 
3. Findeachnotandinvertit.
4. Findanyremainingand/orandsolveit.
5. When you are done you should have True or False. 
  I will demonstrate with a variation on #20:
  3 != 4 and not (”testing” != ”test” or ”Python” == ”Python”)
  Here’s me going through each of the steps and showing you the translation until I’ve boiled it down to a single result:
  1. Solve each equality test:
  3 != 4 is True: True and not ("testing" != "test" or "Python" == "Python") "testing" != "test" is True: True and not (True or "Python" == "Python") "Python" == "Python": True and not (True or True)
2. Find each and/or in parentheses():
(True or True) is True: True and not (True)
3. Findeachnotandinvertit:
not (True) is False: True and False
4. Findanyremainingand/orandsolvethem: True and False is False
With that we’re done and know the result is False.
WARNING! The more complicated ones may seem very hard at first. You should be able to take a good first stab at solving them, but do not get discouraged. I’m just getting you primed for more of these ”logic gymnastics” so that later cool stuff is much easier. Just stick with it, and keep track of what you get wrong, but do not worry that it’s not getting in your head quite yet. It’ll come.


EX.20

>>> True and True
True
>>1 == 1 and 2 == 2
True

x = True
y = False

# Output: x and y is False
print('x and y is',x and y)

# Output: x or y is True
print('x or y is',x or y)

# Output: not x is False
print('not x is',not x)


Identity operators
is and is not are the identity operators in Python. They are used to check if two values (or variables) are located on the same part of the memory. Two variables that are equal does not imply that they are identical.

Identity operators in Python
Operator	Meaning	Example
is	True if the operands are identical (refer to the same object)	x is True
is not	True if the operands are not identical (do not refer to the same object)	x is not True

Terminal Ex:
>>> x = 5
>>> type(x) is int
True
>>> type(x) is not float
True
>>> y = 3.23
>>> type(y) is not float
False
>>> type(y) is int
False

Terminal Ex:
x = 20
y = 20
if ( x is y ): 
	print("x & y  SAME identity")
y=30
if ( x is not y ):
	print("x & y have DIFFERENT identity")
  
Membership operators
in and not in are the membership operators in Python. 
They are used to test whether a value or variable is found in a sequence (string, list, tuple, set and dictionary).
In a dictionary we can only test for presence of key, not the value.

Operator- Meaning
  Example
in	- True 
  if value/variable is found in the sequence	5 in x
not in	- True 
  if value/variable is not found in the sequence	5 not in x


 
 #Arithmetic Operators
x= 4	
y= 5
print x + y

#Comparison Operators
x = 4
y = 5
print('x > y  is',x>y)

#Assignment Operators
num1 = 4
num2 = 5
print ("Line 1 - Value of num1 : ", num1)
print ("Line 2 - Value of num2 : ", num2)

#compound assignment operator
num1 = 4
num2 = 5
res = num1 + num2
res += num1
print ("Line 1 - Result of + is ", res)

#Logical Operators
a = True
b = False
print('a and b is',a and b)
print('a or b is',a or b)
print('not a is',not a)

#Membership Operators
x = 4
y = 8
list = [1, 2, 3, 4, 5 ];
if ( x in list ):
   print "Line 1 - x is available in the given list"
else:
   print "Line 1 - x is not available in the given list"
if ( y not in list ):
   print "Line 2 - y is not available in the given list"
else:
   print "Line 2 - y is available in the given list"

#Identity Operators
x = 20
y = 20
if ( x is y ):
	print "x & y  SAME identity"
y=30
if ( x is not y ):
	print "x & y have DIFFERENT identity"

#Operator precedence
v = 4
w = 5
x = 8
y = 2
z = 0
z = (v+w) * x / y;   
print "Value of (v+w) * x/ y is ",  z



Functions and Variables
Functions may have been a mind-blowing amount of information, but do not worry. 
Just keep doing these exercises and going through your checklist from the last exercise and you 
will eventually get it.
There is one tiny point that you might not have realized, which we’ll reinforce right now. 
The variables in your function are not connected to the variables in your script. Here’s an exercise to get you thinking about this:


Syntax of Function

def function_name(parameters):
	"""docstring"""
	statement(s)
  
Terminal EX:
def greet(name):
	"""This function greets to
	the person passed in as
	parameter"""
	print("Hello, " + name + ". Good morning!")

How do you call a function?
>>> greet('Paul')
Hello, Paul. Good morning!

>>> print(greet.__doc__)
This function greets to
	the person passed into the
	name parameter
	
Docstring
The first string after the function header is called the docstring and is short for documentation string. 
It is used to explain in brief, what a function does.

Although optional, documentation is a good programming practice.

The return statement
The return statement is used to exit a function and go back to the place from where it was called.

Syntax of return
return [expression_list]

This statement can contain expression which gets evaluated and the value is returned. 
If there is no expression in the statement or the return statement itself is not present inside a function, 
then the function will return the None object.

Terminal EX:

def absolute_value(num):
	"""This function returns the absolute
	value of the entered number"""

	if num >= 0:
		return num
	else:
		return -num

# Output: 2
print(absolute_value(2))

# Output: 4
print(absolute_value(-4))

Scope and Lifetime of variables
Scope of a variable is the portion of a program where the variable is recognized. 
Parameters and variables defined inside a function is not visible from outside. Hence, they have a local scope.
Lifetime of a variable is the period throughout which the variable exits in the memory. 
The lifetime of variables inside a function is as long as the function executes.
They are destroyed once we return from the function. 
Hence, a function does not remember the value of a variable from its previous calls.

def my_func():
	x = 10
	print("Value inside function:",x)

x = 20
my_func()
print("Value outside function:",x)

Types of Functions:
Python Built-in Function

print(*objects, sep=' ', end='\n', file=sys.stdout)¶
	Print objects to the stream file, separated by sep and followed by end. sep, end and file, 
	if present, must be given as keyword arguments.

range(stop)¶
range(start, stop[, step])
	This is a versatile function to create lists containing arithmetic progressions. 
	It is most often used in for loops. The arguments must be plain integers. 
	If the step argument is omitted, it defaults to 1. 
	If the start argument is omitted, it defaults to 0. 
	The full form returns a list of plain integers [start, start + step, start + 2 * step, ...]. 
	If step is positive, the last element is the largest start + i * step less than stop; 
	if step is negative, the last element is the smallest start + i * step greater than stop. 
	step must not be zero (or else ValueError is raised). 
	
Terminal Example:
	>>> range(10)
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	>>> range(1, 11)
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> range(0, 30, 5)
	[0, 5, 10, 15, 20, 25]
	>>> range(0, 10, 3)
	[0, 3, 6, 9]
	>>> range(0, -10, -1)
	[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
	>>> range(0)
	[]
	>>> range(1, 0)

enumerate(sequence, start=0)
	Returns an enumerate object. 
	sequence must be a sequence, an iterator, or some other object which supports iteration. 
	The next() method of the iterator returned by enumerate() returns a tuple containing a 
	count (from start which defaults to 0) and the values obtained from iterating over sequence:
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
Equivalent to:

def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
	
Lets go  through this for few minutes
 	https://docs.python.org/2/library/functions.html

User Defined Functions : we build this

Pass by reference vs value
All parameters (arguments) in the Python language are passed by reference. 
It means if you change what a parameter refers to within a function, the change also reflects back in the calling function. 


For example −
Here, we are maintaining reference of the passed object and appending values in the same object.
# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   mylist.append([1,2,3,4]);
   print "Values inside the function: ", mylist
   return

# Now you can call changeme function
mylist = [10,20,30];
changeme( mylist );
print "Values outside the function: ", mylist


# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   mylist = [1,2,3,4]; # This would assig new reference in mylist
   print "Values inside the function: ", mylist
   return

# Now you can call changeme function
mylist = [10,20,30];
changeme( mylist );
print "Values outside the function: ", mylist


This shows all the different ways we’re able to give our function cheese_and_crackers 
the values it needs to print them. We can give it straight numbers. 
We can give it variables. We can give it math. We can even combine math and variables.
In a way, the arguments to a function are kind of like our = character when we make a variable. 
In fact, if you can use = to name something, you can usually pass it to a function as an argument.



